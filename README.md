Collision Detection System
Overview
This exploration game of the 3D nature has a circle-vs-OBB (Oriented Bounding Box) collision detection system, which is used to ensure that the player does not clip through walls and furniture. The collision system is based on the XZ-plane (on the ground) and is oriented bounding boxes to the footprints of all the static geometry - the walls of the lab, door, bed, desk, wardrobe and side table. Every OBB contains its center position on the world-space, half-extents (width and depth), rotation angle (yaw) and vertical span(Y-range). The CircleOverlapsObb approach converts the circular radius of collision of the player into the local space of each OBB, identifies closest point of the box, and calculates a push-out vector in the event of penetration. This method deals with rotated colliders gracefully and gives nice and flowing edge-sliding collision responses without corner sticking.
Integration with Movement and Rendering Movement Integration Movement Rendering Integration Rendering Integration with Movement and Rendering Movement Integration Movement Rendering Movement Rendering Integration with Movement and Rendering Movement Integration Movement Rendering Movement Rendering Integration with Movement and Rendering Movement Integration Movement Rendering Movement Rendering Integration with Movement and Rendering Movement Integration Movement Rendering Movement Rendering Integration with Movement and Rendering Movement Movement Rendering Movement Rendering Integration with Movement and Rendering Movement Movement Rendering Movement R
The collision system is closely built into the game loop of updates and rendering. OnUpdateFrame: Once the camera position has been updated according to input, the ResolveCircleVsScene algorithm processes through all the registered OBBs and applies minimum push-out vectors to eliminate any overlaps. This makes sure that the player is controls pushed off obstacles softly and slide sliding down the edges. The CollisionManager contains all the collision logic and has a list of OBBs, which is read-only and is recreated whenever models are loaded or the scene is restarted. As a debugging measure, pressing B turns wireframe visualization of all boxes with collision visualization on using DrawCollisionDebug, and the outlines appear as green lines in the same coordinate space as the game world. The collision boxes have been scaled and rotated appropriately to fit their corresponding models transforms such that it is not difficult to verify that the colliders are consistent with the visual geometry.
Challenges and Solutions
The main problem was to scale collision boxes correctly between models of enormously different scales, the bed model is scaled by 0.0015, the desk model is scaled by 21 and the wardrobe model is scaled by 0.009. At first, the collision sizes were defined as values in world-space, thus resulting in either invisible colliders or huge phantom boxes. The answer was to define all collision sizes in model-local space and use the AddCompoundModelCollider method to automatically resize them by the transformation of the model. The other issue was to make sure that the debug visualization was corresponding to the real collision logic. The original wireframe drawing hardcoded the height value rather than the actual MinY and MaxY range of the OBB resulting in boxes appearing in the wrong place. This was corrected by dynamically calculating the height based on the vertical span of the OBB and centering the visual box by that. And lastly, a remnant of the previous development, being a massive bang box at (-50, 0, 50), was causing unwanted collisions until it was taken out of the setup code. The ability to add console output when setting up collision was very valuable in determining the models with null references or wrong sizes when debugging.
